<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Claw Machine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 24px;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 14px;
            z-index: 10;
        }
        #video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 3px solid white;
            border-radius: 10px;
            display: none;
            z-index: 10;
        }
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 10;
        }
        .pixel {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>SCORE: <span id="score">0</span></div>
            <div>PRIZES: <span id="prizes">0</span></div>
        </div>
        <div id="instructions">
            <strong>ðŸŽ® HOW TO PLAY</strong><br><br>
            <strong>Hand Control:</strong><br>
            â€¢ Move hand left/right to position claw<br>
            â€¢ Close fist to drop claw<br><br>
            <strong>Keyboard:</strong><br>
            â€¢ Arrow keys: Move claw<br>
            â€¢ SPACE: Drop claw
        </div>
        <video id="video" autoplay playsinline class="pixel"></video>
        <div id="status">Initializing...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // Game state
        let scene, camera, renderer;
        let claw, clawGroup, cable;
        let prizes = [];
        let score = 0;
        let prizesCollected = 0;
        let clawState = 'idle'; // idle, descending, grabbing, ascending, returning
        let clawX = 0;
        let clawY = 5;
        let clawZ = 0;
        let targetClawX = 0;
        let grabbedPrize = null;
        let handTracking = false;
        let lastHandX = 0;

        // MediaPipe hands
        let hands, camera_mp;

        // Initialize Three.js
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 2, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            renderer.domElement.id = 'canvas';

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create machine
            createMachine();
            createClaw();
            createPrizes();

            // Setup controls
            setupControls();
            
            // Start MediaPipe
            initMediaPipe();

            // Animation loop
            animate();
        }

        function createMachine() {
            // Floor
            const floorGeometry = new THREE.BoxGeometry(8, 0.2, 6);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            scene.add(floor);

            // Glass walls (semi-transparent)
            const glassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.3 
            });

            // Front wall
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 0.1), glassMaterial);
            frontWall.position.set(0, 4, 3);
            scene.add(frontWall);

            // Back wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 0.1), glassMaterial);
            backWall.position.set(0, 4, -3);
            scene.add(backWall);

            // Side walls
            const sideWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 8, 6), glassMaterial);
            sideWall1.position.set(-4, 4, 0);
            scene.add(sideWall1);

            const sideWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 8, 6), glassMaterial);
            sideWall2.position.set(4, 4, 0);
            scene.add(sideWall2);

            // Top
            const top = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 6), new THREE.MeshLambertMaterial({ color: 0xff6b6b }));
            top.position.y = 8;
            scene.add(top);

            // Prize chute
            const chuteGeometry = new THREE.BoxGeometry(1.5, 1, 1);
            const chuteMaterial = new THREE.MeshLambertMaterial({ color: 0xffdd57 });
            const chute = new THREE.Mesh(chuteGeometry, chuteMaterial);
            chute.position.set(5, 0.5, 0);
            scene.add(chute);
        }

        function createClaw() {
            clawGroup = new THREE.Group();

            // Cable
            const cableGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const cableMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            cable = new THREE.Mesh(cableGeometry, cableMaterial);
            cable.position.y = 0.5;
            clawGroup.add(cable);

            // Claw head
            const clawHeadGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.6);
            const clawHeadMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
            const clawHead = new THREE.Mesh(clawHeadGeometry, clawHeadMaterial);
            clawHead.castShadow = true;
            clawGroup.add(clawHead);

            // Claw fingers
            const fingerGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            const fingerMaterial = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });

            for (let i = 0; i < 4; i++) {
                const finger = new THREE.Mesh(fingerGeometry, fingerMaterial);
                const angle = (i * Math.PI) / 2;
                finger.position.x = Math.cos(angle) * 0.25;
                finger.position.z = Math.sin(angle) * 0.25;
                finger.position.y = -0.4;
                clawGroup.add(finger);
            }

            clawGroup.position.set(clawX, clawY, clawZ);
            scene.add(clawGroup);
            claw = clawGroup;
        }

        function createPrizes() {
            const prizeColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0xa8e6cf, 0xff8b94, 0xc7ceea];
            
            for (let i = 0; i < 12; i++) {
                const size = 0.4 + Math.random() * 0.3;
                const geometry = new THREE.BoxGeometry(size, size, size);
                const material = new THREE.MeshLambertMaterial({ 
                    color: prizeColors[Math.floor(Math.random() * prizeColors.length)] 
                });
                const prize = new THREE.Mesh(geometry, material);
                
                prize.position.x = -3 + Math.random() * 6;
                prize.position.y = size / 2;
                prize.position.z = -2 + Math.random() * 4;
                
                prize.castShadow = true;
                prize.receiveShadow = true;
                prize.userData.grabbed = false;
                
                scene.add(prize);
                prizes.push(prize);
            }
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (clawState !== 'idle') return;

                if (e.key === 'ArrowLeft') {
                    targetClawX = Math.max(-3.5, clawX - 0.5);
                } else if (e.key === 'ArrowRight') {
                    targetClawX = Math.min(3.5, clawX + 0.5);
                } else if (e.key === ' ') {
                    dropClaw();
                }
            });
        }

        function dropClaw() {
            if (clawState === 'idle') {
                clawState = 'descending';
                updateStatus('Dropping claw...');
            }
        }

        function updateClawPosition() {
            // Smooth movement toward target
            if (Math.abs(targetClawX - clawX) > 0.01) {
                clawX += (targetClawX - clawX) * 0.1;
            }

            // State machine
            if (clawState === 'descending') {
                clawY -= 0.08;
                if (clawY <= 0.5) {
                    clawY = 0.5;
                    clawState = 'grabbing';
                    checkGrab();
                }
            } else if (clawState === 'grabbing') {
                // Brief pause
                setTimeout(() => {
                    clawState = 'ascending';
                }, 300);
            } else if (clawState === 'ascending') {
                clawY += 0.08;
                if (clawY >= 5) {
                    clawY = 5;
                    clawState = 'returning';
                }
            } else if (clawState === 'returning') {
                // Move toward chute
                targetClawX = 4;
                if (Math.abs(clawX - 4) < 0.2 && Math.abs(clawY - 5) < 0.1) {
                    // Drop prize
                    if (grabbedPrize) {
                        scene.remove(grabbedPrize);
                        prizes = prizes.filter(p => p !== grabbedPrize);
                        score += 100;
                        prizesCollected++;
                        updateScore();
                        updateStatus('Prize collected! +100 points');
                        grabbedPrize = null;
                    } else {
                        updateStatus('Missed! Try again.');
                    }
                    clawState = 'idle';
                    targetClawX = 0;
                }
            }

            // Update claw position
            clawGroup.position.set(clawX, clawY, clawZ);
            
            // Update cable length
            cable.scale.y = (8 - clawY) / 1;
            cable.position.y = (8 - clawY) / 2;

            // Update grabbed prize position
            if (grabbedPrize && clawState !== 'idle') {
                grabbedPrize.position.set(clawX, clawY - 0.5, clawZ);
            }
        }

        function checkGrab() {
            let closestPrize = null;
            let closestDist = 0.8;

            prizes.forEach(prize => {
                if (prize.userData.grabbed) return;
                
                const dist = Math.sqrt(
                    Math.pow(prize.position.x - clawX, 2) +
                    Math.pow(prize.position.z - clawZ, 2)
                );

                if (dist < closestDist) {
                    closestDist = dist;
                    closestPrize = prize;
                }
            });

            // 70% success rate if close enough
            if (closestPrize && Math.random() > 0.3) {
                grabbedPrize = closestPrize;
                grabbedPrize.userData.grabbed = true;
                updateStatus('Got one!');
            } else {
                updateStatus('Claw missed...');
            }
        }

        function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const videoElement = document.getElementById('video');
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.style.display = 'block';
                        
                        camera_mp = new Camera(videoElement, {
                            onFrame: async () => {
                                await hands.send({ image: videoElement });
                            },
                            width: 640,
                            height: 480
                        });
                        camera_mp.start();
                        
                        handTracking = true;
                        updateStatus('Hand tracking active!');
                    })
                    .catch(err => {
                        console.warn('Camera access denied:', err);
                        updateStatus('Use keyboard controls');
                    });
            } else {
                updateStatus('Use keyboard controls');
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Get hand center (wrist)
                const wrist = landmarks[0];
                const handX = (wrist.x - 0.5) * 2; // Map to -1 to 1
                
                // Map to claw position
                if (clawState === 'idle') {
                    targetClawX = handX * 3.5; // Map to -3.5 to 3.5
                }

                // Detect fist (check if fingers are closed)
                const indexTip = landmarks[8];
                const indexBase = landmarks[5];
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - indexBase.x, 2) +
                    Math.pow(indexTip.y - indexBase.y, 2)
                );

                // If hand is closed (fist), drop claw
                if (distance < 0.05 && clawState === 'idle') {
                    dropClaw();
                }

                lastHandX = handX;
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('prizes').textContent = prizesCollected;
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateClawPosition();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        init();
        updateStatus('Ready! Move claw and press SPACE');
    </script>
</body>
</html>